/// \file
/// \brief Contains definitions of built-in execution policies.
///

/// \defgroup execution_policies Execution Policies
/// \ingroup execution
/// \brief Execution policies describe requirements for execution.
///
/// Execution policies describe the execution properties of bulk tasks created by control structures such as `bulk_invoke()`.
/// Such properties include both *how* and *where* execution should occur. Forward progress requirements encapsulated by 
/// execution policies describe the ordering relationships of individual execution agents comprising a bulk task, while the execution policy's
/// associated *executor* governs where those execution agents execute.
///
/// ### Essential Characteristics
///
/// An execution policy collects two essential characteristics: a type of execution agent defining execution requirements,
/// and an associated executor which creates execution with prescribed guarantees. When combined with control structures
/// like bulk_invoke(), the associated executor creates execution and the characteristics of this execution are reified
/// in the program as execution agent objects.
///
/// ### Parameterization
///
/// Aside from these characteristics, execution policy objects also encapsulate a *parameterization* describing
/// the group of execution agents to create when composed with a control structure. For most of Agency's execution agent types,
/// these parameters define the range of indices assigned to agents in the group.
///
/// An existing instance of an execution policy may be called like a function to produce a different an instance with a
/// different parameterization. For example, the execution policy agency::par may be called like a function to create a new
/// policy with a different parameterization:
///
/// ~~~~{.cpp}
/// // call seq like a function to produce an execution policy generating 13 agents
/// agency::bulk_invoke(agency::seq(13), [](agency::sequenced_agent& self)
/// {
///   std::cout << self.index() << std::endl;
/// });
///
/// // the integers [0,13) are printed in sequence
/// ~~~~
///
/// Alternatively, we can shift the origin of the group by passing agency::seq a half-open range:
///
/// ~~~~{.cpp}
/// agency::bulk_invoke(agency::seq(10,23), [](agency::sequenced_agent& self)
/// {
///   std::cout << self.index() << std::endl;
/// });
///
/// // the integers [10,23) are printed in sequence
/// ~~~~
///
/// ### The associated executor
///
/// Each of Agency's execution policies have an associated executor. The member function `.executor()` provides access to this executor:
///
/// ~~~~{.cpp}
/// // make a copy of par's associated executor
/// agency::parallel_executor par_exec = agency::par.executor();
/// ~~~~
///
/// The type of an execution policy's associated executor is named by the member type `executor_type`. Generic contexts such as templates may use this type:
///
/// ~~~~{.cpp}
/// template<class ExecutionPolicy>
/// void foo(ExecutionPolicy& policy)
/// {
///   // use the member type executor_type to make a copy of policy's associated executor
///   typename ExecutionPolicy::executor_type exec1 = policy.executor();
///
///   // alternatively, use auto
///   auto exec2 = policy.executor();
///
///   ...
/// }
/// ~~~~
///
/// ### Replacing an executor with `.on()`
///
/// An existing execution policy's associated executor may be *replaced* with the `.on()` member function. `.on()`
/// creates a new execution policy object whose associated executor is a copy of the given executor:
///
/// ~~~~{.cpp}
/// // suppose I have some existing executor
/// agency::sequenced_executor my_executor;
///
/// // associate my_executor with a new policy derived from agency::par
/// auto new_policy = agency::par.on(my_executor);
///
/// // now all execution generated by new_policy will be created "on" my_executor
/// ~~~~

#pragma once

#include <utility>
#include <functional>
#include <type_traits>
#include <functional>
#include <memory>
#include <tuple>
#include <initializer_list>

#include <agency/detail/tuple.hpp>
#include <agency/execution/executor.hpp>
#include <agency/execution/execution_agent.hpp>
#include <agency/execution/detail/execution_policy_traits.hpp>

namespace agency
{


template<class T>
struct is_execution_policy : detail::conjunction<
  detail::has_execution_agent_type<T>,
  detail::has_executor<T>,
  detail::has_param<T>
> {};


// declare basic_execution_policy for replace_executor()'s signature below 
template<class ExecutionAgent,
         class BulkExecutor,
         class DerivedExecutionPolicy = void>
class basic_execution_policy;


// declare replace_executor() so basic_execution_policy.on() can use it below
template<class ExecutionPolicy, class Executor>
basic_execution_policy<
  typename ExecutionPolicy::execution_agent_type,
  Executor>
replace_executor(const ExecutionPolicy& policy, const Executor& exec);


namespace detail
{


template<class... Types>
struct last_type_impl
{
  typedef typename std::tuple_element<sizeof...(Types) - 1, std::tuple<Types...>>::type type;
};


template<>
struct last_type_impl<>
{
  typedef void type;
};


template<class... Types>
using last_type = typename last_type_impl<Types...>::type;


template<class ParamType, class... Args>
struct is_scoped_call
  : std::integral_constant<
      bool,
      is_execution_policy<last_type<Args...>>::value &&
      is_constructible_from_type_list<
        ParamType,
        type_list_drop_last<
          type_list<Args...>
        >
      >::value
    >
{};


template<class ParamType, class... Args>
struct is_flat_call
  : std::integral_constant<
      bool,
      is_constructible_from_type_list<ParamType, type_list<Args...>>::value
    >
{};


// declare scoped_execution_policy for basic_execution_policy's use below
template<class ExecutionPolicy1, class ExecutionPolicy2>
class scoped_execution_policy;


} // end detail


/// \brief The basic type from which all of Agency's execution policies derive their common functionality.
/// \ingroup execution_policies
///
///
/// basic_execution_policy defines the essential functionality which all of Agency's execution policies share in common.
/// Because all of Agency's execution policy types publicly inherit from basic_execution_policy, the documentation for
/// their common, public functionality is collected here.
///
/// basic_execution_policy may also be used to define custom execution policy types by instantiating basic_execution_policy
/// with an execution agent type and an executor type. Either of these types may be user-defined.
///
/// \tparam ExecutionAgent The type of execution agent created by the basic_execution_policy.
/// \tparam Executor The type of executor associated with the basic_execution_policy.
/// \tparam DerivedExecutionPolicy The name of the execution policy deriving from this basic_execution_policy.
///         `void` indicates that no execution policy will be derived from this basic_execution_policy.
template<class ExecutionAgent,
         class Executor,
         class DerivedExecutionPolicy>
class basic_execution_policy
{
  public:
    // validate that it makes sense to execute the agent's requirements using the executor's guarantees
    static_assert(detail::is_weaker_than<
                    typename execution_agent_traits<ExecutionAgent>::execution_category,
                    executor_execution_category_t<Executor>
                  >::value,
                  "basic_execution_policy: ExecutionAgent's forward progress requirements cannot be satisfied by Executor's guarantees."
    );

    /// \brief The type of execution agent associated with this basic_execution_policy.
    using execution_agent_type = ExecutionAgent;

    /// \brief The type of executor associated with this basic_execution_policy.
    using executor_type        = Executor;

  private:
    using derived_type         = typename std::conditional<
      std::is_same<DerivedExecutionPolicy,void>::value,
      basic_execution_policy,
      DerivedExecutionPolicy
    >::type;

  public:
    /// \brief The type of this execution policy's parameterization.
    using param_type           = typename execution_agent_traits<execution_agent_type>::param_type;

    /// \brief The default constructor default constructs this execution policy's associated executor and parameterization.
    basic_execution_policy() = default;

    /// \brief This constructor constructs a new basic_execution_policy given a parameterization and executor.
    /// \param param The parameterization of this basic_execution_policy.
    /// \param executor The executor to associate with this basic_execution_policy.
    basic_execution_policy(const param_type& param, const executor_type& executor = executor_type{})
      : param_(param),
        executor_(executor)
    {}

    /// \brief Returns this execution policy's parameterization.
    const param_type& param() const
    {
      return param_;
    }

    /// \brief Returns this execution policy's associated executor.
    executor_type& executor() const
    {
      return executor_;
    }

    /// \brief Replaces this execution policy's executor with another.
    ///
    ///
    /// on() returns a new execution policy identical to `*this` but
    /// whose associated executor has been replaced by another executor.
    ///
    /// For example, we can require an otherwise parallel task to execute sequentially
    /// in the current thread by executing the task on a sequenced_executor:
    ///
    /// ~~~~{.cpp}
    /// agency::sequenced_executor seq_exec;
    ///
    /// // require the parallel_agents induced by par to execute sequentially on seq_exec
    /// agency::bulk_invoke(agency::par(10).on(seq_exec), [](agency::parallel_agent& self)
    /// {
    ///   std::cout << self.index() << std::endl;
    /// });
    ///
    /// // the integers [0,10) are printed in sequence
    /// ~~~~
    ///
    /// Note that using on() does not change the type of execution agent object created by the policy;
    /// it only changes the underlying physical execution of these agents. The relative
    /// forward progress characteristics of the execution agents required by the execution policy
    /// and the forward progress guarantees must make sense; the forward progress guarantees made by
    /// the executor may not weaken the requirements of the policy. A program that attempts to do this
    /// is ill-formed and will not compile. In this example's case, because agency::sequenced_executor
    /// makes a stronger guarantee (sequenced execution) than does agency::par (parallel execution),
    /// the program is well-formed.
    /// 
    ///
    /// \param exec The other executor to associate with the returned execution policy.
    /// \return An execution policy equivalent to `*this` but whose associated executor is a copy of `exec`.
    ///         The type of the result is an execution policy type `Policy` with the following characteristics:
    ///           * `Policy::execution_agent_type` is `execution_agent_type`,
    ///           * `Policy::param_type` is `param_type`
    ///           * `Policy::executor_type` is `OtherExecutor`.
    /// \note The given executor's forward progress guarantees must not be weaker than this
    ///       execution policy's forward progress requirements.
    /// \note on() is sugar for the expression `replace_executor(*this, exec)`.
    /// \see replace_executor
    template<class OtherExecutor>
    auto on(const OtherExecutor& exec) const ->
      decltype(replace_executor(*this, exec))
    {
      // note the intentional use of ADL to call replace_executor()
      return replace_executor(*this, exec);
    }

    /// \brief Reparameterizes this execution policy.
    ///
    ///
    /// `operator()` returns a new execution policy identical to `*this` but whose
    /// parameterization is constructed from the given arguments.
    ///
    /// \param arg1 The first argument to forward to `param_type`'s constructor.
    /// \param args The rest of the arguments to forward to `param_type`'s constructor.
    /// \return An execution policy equivalent to `*this` but whose parameterization has been constructed from the given arguments.
    ///         The type of the result is:
    ///           * `DerivedExecutionPolicy`, when `DerivedExecutionPolicy` is not `void`
    ///           * `basic_execution_policy<ExecutionAgent,Executor,void>`, otherwise.
    ///
    // this is the flat form of operator()
    // XXX consider introducing .reparamterize() that makes it clearer exactly what is going on
    template<class Arg1, class... Args>
    #ifndef DOXYGEN_SHOULD_SKIP_THIS
    typename std::enable_if<
      detail::is_flat_call<param_type, Arg1, Args...>::value,
      derived_type
    >::type
    #else
    see_below
    #endif
      operator()(Arg1&& arg1, Args&&... args) const
    {
      return derived_type{param_type{std::forward<Arg1>(arg1), std::forward<Args>(args)...}, executor()};
    }

    // XXX maybe .scope() should just take OuterPolicy & InnerPolicy?
    //     instead of a bunch of args?
    // XXX seems like scope() should require at least two arguments
    template<class Arg1, class... Args>
    detail::scoped_execution_policy<
      derived_type,
      detail::decay_t<detail::last_type<Arg1,Args...>>
    >
      scope(Arg1&& arg1, Args&&... args) const
    {
      // wrap the args in a tuple so we can manipulate them easier
      auto arg_tuple = detail::forward_as_tuple(std::forward<Arg1>(arg1), std::forward<Args>(args)...);

      // get the arguments to the outer execution policy
      auto outer_args = detail::tuple_drop_last(arg_tuple);

      // create the outer execution policy
      auto outer = detail::tuple_apply(*this, outer_args);

      // get the inner execution policy
      auto inner = __tu::tuple_last(arg_tuple);

      // return the composition of the two policies
      return detail::scoped_execution_policy<derived_type,decltype(inner)>(outer, inner);
    }

    // this is the scoped form of operator()
    // it is just sugar for .scope()
    template<class Arg1, class... Args>
    typename std::enable_if<
      detail::is_scoped_call<param_type, Arg1, Args...>::value,
      detail::scoped_execution_policy<
        derived_type,
        detail::decay_t<detail::last_type<Arg1,Args...>>
      >
    >::type
      operator()(Arg1&& arg1, Args&&... args) const
    {
      return scope(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
    }

    template<class Arg1, class... Args>
    derived_type operator()(std::initializer_list<Arg1> arg1, std::initializer_list<Args>... args) const
    {
      return derived_type{param_type{std::move(arg1), std::move(args)...}, executor()};
    }

  protected:
    param_type param_;

    // executor_ needs to be mutable, because:
    // * the global execution policy objects are constexpr
    // * executor's member functions are not const
    mutable executor_type executor_;
};


namespace detail
{


template<class ExecutionPolicy1, class ExecutionPolicy2>
class scoped_execution_policy
  : public basic_execution_policy<
      execution_group<
        typename ExecutionPolicy1::execution_agent_type,
        typename ExecutionPolicy2::execution_agent_type
      >,
      scoped_executor<
        typename ExecutionPolicy1::executor_type,
        typename ExecutionPolicy2::executor_type
      >,
      scoped_execution_policy<ExecutionPolicy1,ExecutionPolicy2>
    >
{
  private:
    using super_t = basic_execution_policy<
      execution_group<
        typename ExecutionPolicy1::execution_agent_type,
        typename ExecutionPolicy2::execution_agent_type
      >,
      scoped_executor<
        typename ExecutionPolicy1::executor_type,
        typename ExecutionPolicy2::executor_type
      >,
      scoped_execution_policy<ExecutionPolicy1,ExecutionPolicy2>
    >;


  public:
    using outer_execution_policy_type = ExecutionPolicy1;
    using inner_execution_policy_type = ExecutionPolicy2;
    using typename super_t::execution_agent_type;
    using typename super_t::executor_type;

    scoped_execution_policy(const outer_execution_policy_type& outer,
                            const inner_execution_policy_type& inner)
      : super_t(typename execution_agent_type::param_type(outer.param(), inner.param()),
                executor_type(outer.executor(), inner.executor())),
        outer_(outer),
        inner_(inner)
    {}

    const outer_execution_policy_type& outer() const
    {
      return outer_;
    }

    const inner_execution_policy_type& inner() const
    {
      return inner_;
    }

  private:
    outer_execution_policy_type outer_;
    inner_execution_policy_type inner_;
};


} // end detail


template<class ExecutionPolicy, class Executor>
basic_execution_policy<
  typename ExecutionPolicy::execution_agent_type,
  Executor
>
replace_executor(const ExecutionPolicy& policy, const Executor& exec)
{
  using policy_category = detail::execution_policy_execution_category_t<ExecutionPolicy>;
  using executor_category = executor_execution_category_t<Executor>;

  static_assert(detail::is_weaker_than<policy_category, executor_category>::value, "replace_executor(): Execution policy's forward progress requirements cannot be satisfied by executor's guarantees.");

  using result_type = basic_execution_policy<
    typename ExecutionPolicy::execution_agent_type,
    Executor
  >;

  return result_type(policy.param(), exec);
}


// What follows are the definitions of Agency's built-in execution policy
// types. These are all defined by inheriting from basic_execution_policy,
// using the appropriate types as template parameters to describe their
// essential characteristics. We use inheritance, instead of making a simple
// typedef of basic_execution_policy, for the sake of better documentation and
// compiler error messages. Defining a unique type like
// sequenced_execution_policy ensures that "sequenced_execution_policy" appears
// in compiler output, instead of some type recipe involving
// basic_execution_policy.


/// \brief Encapsulates requirements for creating groups of sequenced execution agents.
/// \ingroup execution_policies
///
///
/// When used as a control structure parameter, `sequenced_execution_policy` requires the creation of a group of execution agents which execute in sequence.
/// Agents in such a group execute on the thread which invokes the control structure. However, if the executor of a `sequenced_execution_policy` is replaced
/// with another sequenced executor of a different type, the agents may execute in sequence on another thread or threads, depending on the type of that executor.
///
/// The order in which sequenced execution agents execute is given by the lexicographical order of their indices.
///
/// The type of execution agent `sequenced_execution_policy` induces is `sequenced_agent`, and the type of its associated executor is `sequenced_executor`.
///
/// \see execution_policies
/// \see basic_execution_policy
/// \see seq
/// \see sequenced_agent
/// \see sequenced_executor
/// \see sequenced_execution_tag
class sequenced_execution_policy : public basic_execution_policy<sequenced_agent, sequenced_executor, sequenced_execution_policy>
{
  private:
    using super_t = basic_execution_policy<sequenced_agent, sequenced_executor, sequenced_execution_policy>;

  public:
    using super_t::basic_execution_policy;
};


/// \brief The global variable `seq` is the default `sequenced_execution_policy`.
/// \ingroup execution_policies
constexpr sequenced_execution_policy seq{};


/// \brief Encapsulates requirements for creating groups of concurrent execution agents.
/// \ingroup execution_policies
///
///
/// When used as a control structure parameter, `concurrent_execution_policy` requires the creation of a group of execution agents which execute concurrently.
/// Agents in such a group are guaranteed to make forward progress.
///
/// The type of execution agent `concurrent_execution_policy` induces is `concurrent_agent`, and the type of its associated executor is `concurrent_executor`.
///
/// \see execution_policies
/// \see basic_execution_policy
/// \see con
/// \see concurrent_agent
/// \see concurrent_executor
/// \see concurrent_execution_tag
class concurrent_execution_policy : public basic_execution_policy<concurrent_agent, concurrent_executor, concurrent_execution_policy>
{
  private:
    using super_t = basic_execution_policy<concurrent_agent, concurrent_executor, concurrent_execution_policy>;

  public:
    using super_t::basic_execution_policy;
};


/// \brief The global variable `con` is the default `concurrent_execution_policy`.
/// \ingroup execution_policies
constexpr concurrent_execution_policy con{};


/// \brief Encapsulates requirements for creating groups of parallel execution agents.
/// \ingroup execution_policies
///
///
/// When used as a control structure parameter, `parallel_execution_policy` requires the creation of a group of execution agents which execute in parallel.
/// When agents in such a group execute on separate threads, they have no order. Otherwise, if agents in such a group execute on the same thread,
/// they execute in an unspecified order.
///
/// The type of execution agent `parallel_execution_policy` induces is `parallel_agent`, and the type of its associated executor is `parallel_executor`.
///
/// \see execution_policies
/// \see basic_execution_policy
/// \see par
/// \see parallel_agent
/// \see parallel_executor
/// \see parallel_execution_tag
class parallel_execution_policy : public basic_execution_policy<parallel_agent, parallel_executor, parallel_execution_policy>
{
  private:
    using super_t = basic_execution_policy<parallel_agent, parallel_executor, parallel_execution_policy>;

  public:
    using super_t::basic_execution_policy;
};


/// \brief The global variable `par` is the default `parallel_execution_policy`.
/// \ingroup execution_policies
const parallel_execution_policy par{};


/// \brief Encapsulates requirements for creating groups of unsequenced execution agents.
/// \ingroup execution_policies
///
///
/// When used as a control structure parameter, `unsequenced_execution_policy` requires the creation of a group of execution agents which execute without any order.
///
/// The type of execution agent `unsequenced_execution_policy` induces is `unsequenced_agent`, and the type of its associated executor is `unsequenced_executor`.
///
/// \see execution_policies
/// \see basic_execution_policy
/// \see vec
/// \see unsequenced_agent
/// \see unsequenced_executor
/// \see unsequenced_execution_tag
class unsequenced_execution_policy : public basic_execution_policy<unsequenced_agent, unsequenced_executor, unsequenced_execution_policy>
{
  private:
    using super_t = basic_execution_policy<unsequenced_agent, unsequenced_executor, unsequenced_execution_policy>;

  public:
    using super_t::basic_execution_policy;
};


/// \brief The global variable `unseq` is the default `unsequenced_execution_policy`.
/// \ingroup execution_policies
constexpr unsequenced_execution_policy unseq{};


namespace experimental
{
namespace detail
{


template<class ExecutionPolicy, std::size_t group_size,
         std::size_t grain_size = 1,
         class ExecutionAgent = basic_static_execution_agent<
           agency::detail::execution_policy_agent_t<ExecutionPolicy>,
           group_size,
           grain_size
         >,
         class Executor       = agency::detail::execution_policy_executor_t<ExecutionPolicy>>
using basic_static_execution_policy = basic_execution_policy<
  ExecutionAgent,
  Executor
>;


} // end detail


template<size_t group_size, size_t grain_size = 1>
class static_sequenced_execution_policy : public detail::basic_static_execution_policy<agency::sequenced_execution_policy, group_size, grain_size>
{
  private:
    using super_t = detail::basic_static_execution_policy<agency::sequenced_execution_policy, group_size, grain_size>;

  public:
    using super_t::super_t;
};


template<size_t group_size, size_t grain_size = 1>
class static_concurrent_execution_policy : public detail::basic_static_execution_policy<
  agency::concurrent_execution_policy,
  group_size,
  grain_size,
  static_concurrent_agent<group_size, grain_size>
>
{
  private:
    using super_t = detail::basic_static_execution_policy<
      agency::concurrent_execution_policy,
      group_size,
      grain_size,
      static_concurrent_agent<group_size, grain_size>
    >;

  public:
    using super_t::super_t;
};


} // end experimental
} // end agency

